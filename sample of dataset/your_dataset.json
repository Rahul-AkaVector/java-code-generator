[
  {
    "instruction": "Write a Java class for a BankAccount that demonstrates encapsulation by encapsulating attributes like account number and balance, abstraction by providing methods for depositing, withdrawing, and checking balance, and inheritance by extending a superclass Account.",
    "input":"",
    "output": "// Superclass Account\nclass Account {\n    private int accountNumber;\n    private double balance;\n\n    public Account(int accountNumber, double balance) {\n        this.accountNumber = accountNumber;\n        this.balance = balance;\n    }\n\n    // Getter methods for encapsulation\n    public int getAccountNumber() {\n        return accountNumber;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n\n    // Abstract method for withdrawing (to be implemented by subclasses)\n    public abstract void withdraw(double amount);\n\n    // Abstract method for depositing (to be implemented by subclasses)\n    public abstract void deposit(double amount);\n}\n\n// Subclass BankAccount\nclass BankAccount extends Account {\n    public BankAccount(int accountNumber, double balance) {\n        super(accountNumber, balance);\n    }\n\n    // Implementing withdraw method\n    @Override\n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= getBalance()) {\n            setBalance(getBalance() - amount);\n            System.out.println(\"Withdrawn: $\" + amount);\n        } else {\n            System.out.println(\"Invalid amount or insufficient balance.\");\n        }\n    }\n\n    // Implementing deposit method\n    @Override\n    public void deposit(double amount) {\n        if (amount > 0) {\n            setBalance(getBalance() + amount);\n            System.out.println(\"Deposited: $\" + amount);\n        } else {\n            System.out.println(\"Invalid amount.\");\n        }\n    }\n}\n\n// Main class to demonstrate the BankAccount class\npublic class Main {\n    public static void main(String[] args) {\n        // Creating a BankAccount object\n        BankAccount account = new BankAccount(123456, 1000.0);\n\n        // Demonstrating encapsulation by accessing account number and balance using getter methods\n        System.out.println(\"Account Number: \" + account.getAccountNumber());\n        System.out.println(\"Balance: $\" + account.getBalance());\n\n        // Depositing and withdrawing money\n        account.deposit(500.0);\n        account.withdraw(200.0);\n\n        // Checking balance after transactions\n        System.out.println(\"New Balance: $\" + account.getBalance());\n    }\n}"
  },
  {
    "instruction": "Create a Java class representing a Vehicle that showcases abstraction by providing abstract methods like start() and stop(), inheritance by having subclasses like Car and Motorcycle, and polymorphism by overriding these methods in each subclass.",
    "input":"",
    "output": "// Abstract class representing a Vehicle\nabstract class Vehicle {\n    // Abstract methods for starting and stopping the vehicle\n    public abstract void start();\n    public abstract void stop();\n}\n\n// Concrete subclass Car inheriting from Vehicle\nclass Car extends Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car started\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Car stopped\");\n    }\n}\n\n// Concrete subclass Motorcycle inheriting from Vehicle\nclass Motorcycle extends Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Motorcycle started\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Motorcycle stopped\");\n    }\n}\n\n// Main class to test the Vehicle hierarchy\npublic class Main {\n    public static void main(String[] args) {\n        // Creating instances of Car and Motorcycle\n        Vehicle car = new Car();\n        Vehicle motorcycle = new Motorcycle();\n\n        // Demonstrating polymorphism\n        car.start();\n        car.stop();\n\n        motorcycle.start();\n        motorcycle.stop();\n    }\n}"
  },
  {
    "instruction": "Design a Java class for a Shape that demonstrates abstraction by providing abstract methods like calculateArea() and calculatePerimeter(), inheritance by having subclasses like Circle and Rectangle, and polymorphism by implementing these methods differently in each subclass.",
    "input":"",
    "output": "// Shape.java\npublic abstract class Shape {\n    // Abstract method to calculate area\n    public abstract double calculateArea();\n    \n    // Abstract method to calculate perimeter\n    public abstract double calculatePerimeter();\n}\n\n// Circle.java\npublic class Circle extends Shape {\n    private double radius;\n\n    // Constructor\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    // Override method to calculate area for Circle\n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n\n    // Override method to calculate perimeter for Circle\n    @Override\n    public double calculatePerimeter() {\n        return 2 * Math.PI * radius;\n    }\n}\n\n// Rectangle.java\npublic class Rectangle extends Shape {\n    private double width;\n    private double height;\n\n    // Constructor\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    // Override method to calculate area for Rectangle\n    @Override\n    public double calculateArea() {\n        return width * height;\n    }\n\n    // Override method to calculate perimeter for Rectangle\n    @Override\n    public double calculatePerimeter() {\n        return 2 * (width + height);\n    }\n}\n\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        // Creating instances of Circle and Rectangle\n        Shape circle = new Circle(5);\n        Shape rectangle = new Rectangle(4, 6);\n\n        // Calculating and printing area and perimeter of Circle\n        System.out.println(\"Circle:\");\n        System.out.println(\"Area: \" + circle.calculateArea());\n        System.out.println(\"Perimeter: \" + circle.calculatePerimeter());\n\n        // Calculating and printing area and perimeter of Rectangle\n        System.out.println(\"\\nRectangle:\");\n        System.out.println(\"Area: \" + rectangle.calculateArea());\n        System.out.println(\"Perimeter: \" + rectangle.calculatePerimeter());\n    }\n}"
  },
  {
    "instruction": "Write a Java class for a Zoo that showcases encapsulation by encapsulating attributes like name and location, inheritance by having subclasses like Mammal and Reptile, and association by associating animals with exhibits.",
    "input":"",
    "output": "public class Zoo {\n  private String name;\n  private String location;\n  private List<Exhibit> exhibits;\n\n  public Zoo(String name, String location) {\n    this.name = name;\n    this.location = location;\n    this.exhibits = new ArrayList<>();\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public String getLocation() {\n    return location;\n  }\n\n  public List<Exhibit> getExhibits() {\n    // Return a copy of the list to avoid modification from outside\n    return new ArrayList<>(exhibits);\n  }\n\n  public void addExhibit(Exhibit exhibit) {\n    exhibits.add(exhibit);\n  }\n}\n\n// Interface for Animal with basic methods\ninterface Animal {\n  String getName();\n  String getSpecies();\n}\n\n// Abstract class for Mammals extending Animal\nabstract class Mammal implements Animal {\n  private String name;\n  private String species;\n\n  public Mammal(String name, String species) {\n    this.name = name;\n    this.species = species;  \n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public String getSpecies() {\n    return species;\n  }\n}\n\n// Similar class for Reptiles extending Animal (you can add specific methods)\nclass Reptile extends Mammal implements Animal {\n  // Add specific reptile attributes and methods here\n\n  public Reptile(String name, String species) {\n    super(name, species);\n  }\n}\n\n// Class for Exhibit associating with Animals\npublic class Exhibit {\n  private String name;\n  private List<Animal> animals;\n\n  public Exhibit(String name) {\n    this.name = name;\n    this.animals = new ArrayList<>();\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public List<Animal> getAnimals() {\n    // Similar to Zoo.getExhibits(), return a copy of the list\n    return new ArrayList<>(animals);\n  }\n\n  public void addAnimal(Animal animal) {\n    animals.add(animal);\n  }\n}"
  },
  {
    "instruction": "Create a Java class for a Library that demonstrates encapsulation by encapsulating attributes like name and address, association by associating books with shelves, and polymorphism by implementing methods like borrow() and return() for different types of library materials.",
    "input":"",
    "output": "class LibraryItem {\n  private String title;\n  // Encapsulated attribute\n  String author;\n\n  public LibraryItem(String title, String author) {\n    this.title = title;\n    this.author = author;\n  }\n\n  public String getTitle() {\n    return title; // Accessor method for encapsulated attribute\n  }\n}\n\nclass Book extends LibraryItem {\n  String genre;\n\n  public Book(String title, String author, String genre) {\n    super(title, author);\n    this.genre = genre;\n  }\n\n  @Override\n  public void borrow() {\n    System.out.println(f\"Borrowing book: {getTitle()} by {author}\");\n  }\n}\n\nclass DVD extends LibraryItem {\n  String director;\n\n  public DVD(String title, String author, String director) {\n    super(title, author);\n    this.director = director;\n  }\n\n  @Override\n  public void borrow() {\n    System.out.println(f\"Borrowing DVD: {getTitle()} by {author} directed by {director}\");\n  }\n}\n\nclass Shelf {\n  String name;\n  List<LibraryItem> items;\n\n  public Shelf(String name) {\n    this.name = name;\n    this.items = new ArrayList<>();\n  }\n\n  public void add_item(LibraryItem item) {\n    items.add(item);\n  }\n\n  public List<LibraryItem> get_items() {\n    return items;\n  }\n}\n\nclass Library {\n  private String name; // Encapsulated attribute\n  String address;\n  Map<String, Shelf> shelves;\n\n  public Library(String name, String address) {\n    this.name = name;\n    this.address = address;\n    this.shelves = new HashMap<>();\n  }\n\n  public String getName() {\n    return name; // Accessor method for encapsulated attribute\n  }\n\n  public void add_shelf(Shelf shelf) {\n    shelves.put(shelf.name, shelf);\n  }\n\n  public void add_item(String shelf_name, LibraryItem item) {\n    if (shelves.containsKey(shelf_name)) {\n      shelves.get(shelf_name).add_item(item);\n    } else {\n      System.out.println(f\"Shelf {shelf_name} does not exist\");\n    }\n  }\n\n  public void borrow_item(String title) {\n    for (Shelf shelf : shelves.values()) {\n      for (LibraryItem item : shelf.get_items()) {\n        if (item.getTitle().equals(title)) {\n          item.borrow();\n          return;\n        }\n      }\n    }\n    System.out.println(f\"Item with title {title} not found\");\n  }\n}\n\n// Example usage\npublic class Main {\n  public static void main(String[] args) {\n    Library library = new Library(\"Central Library\", \"1 Main St\");\n    Shelf shelf_fiction = new Shelf(\"Fiction\");\n    library.add_shelf(shelf_fiction);\n    Book book1 = new Book(\"The Lord of the Rings\", \"J.R.R. Tolkien\", \"Fantasy\");\n    Book book2 = new Book(\"Pride and Prejudice\", \"Jane Austen\", \"Romance\");\n    DVD dvd1 = new DVD(\"The Shawshank Redemption\", \"Frank Darabont\", \"Frank Darabont\");\n    library.add_item(\"Fiction\", book1);\n    library.add_item(\"Fiction\", book2);\n    library.add_item(\"Non-Fiction\", dvd1); // This will print a message\n    library.borrow_item(\"The Lord of the Rings\");\n    library.borrow_item(\"The Catcher in the Rye\"); // This will print a message\n  }\n}"
  },
  {
    "instruction": "Implement a Java class for a Company that exhibits encapsulation by encapsulating attributes like name and revenue, aggregation by aggregating departments, and inheritance by having subclasses like TechCompany and RetailCompany.",
    "input":"",
    "output": "public class Company { \n  // Encapsulated attributes\n  private String name; \n  private double revenue; \n  // Aggregation - Company has departments (an array of Department objects)\n  private Department[] departments; \n  // Constructor with arguments for name and initial departments\n  public Company(String name, Department[] departments) { \n    this.name = name; \n    this.revenue = 0.0; // Initialize revenue to 0 by default\n    this.departments = departments; \n  } \n  // Getter methods for name and revenue\n  public String getName() { \n    return name; \n  } \n  public double getRevenue() { \n    return revenue; \n  } \n  // Method to add revenue to the company\n  public void addRevenue(double amount) { \n    this.revenue += amount; \n  } \n  // Subclasses - TechCompany and RetailCompany (implement these)\n  public static class TechCompany extends Company { \n    // Add specific attributes and methods for TechCompany here\n    public TechCompany(String name, Department[] departments) { \n      super(name, departments); \n    } \n  } \n  public static class RetailCompany extends Company { \n    // Add specific attributes and methods for RetailCompany here\n    public RetailCompany(String name, Department[] departments) { \n      super(name, departments); \n    } \n  } \n} \n  // Example Department class (can be further extended)\n  class Department { \n   private String name; \n   private int employeeCount; \n   public Department(String name, int employeeCount) { \n     this.name = name; \n     this.employeeCount = employeeCount; \n   } \n   // Getter methods for department name and employee count\n   public String getName() { \n     return name; \n   } \n   public int getEmployeeCount() { \n     return employeeCount; \n   } \n }"
  },
  {
    "instruction": "Write a Java class for a Bank that showcases encapsulation by encapsulating attributes like name and location, association by associating customers with accounts, and polymorphism by implementing methods like withdraw() for different types of accounts.",
    "input":"",
    "output": "public class Bank {\n  private String name;\n  private String location;\n\n  public Bank(String name, String location) {\n    this.name = name;\n    this.location = location;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public String getLocation() {\n    return location;\n  }\n\n  // Association with Customer class\n  public void addCustomer(Customer customer) {\n    // Logic to associate customer with the bank\n  }\n}\n\n// Interface for different account types\ninterface Account {\n  public void deposit(double amount);\n  public void withdraw(double amount) throws InsufficientFundsException;\n}\n\n// Savings Account class with specific withdraw logic\nclass SavingsAccount implements Account {\n  private double balance;\n\n  public SavingsAccount(double balance) {\n    this.balance = balance;\n  }\n\n  @Override\n  public void deposit(double amount) {\n    balance += amount;\n  }\n\n  @Override\n  public void withdraw(double amount) throws InsufficientFundsException {\n    if (amount > balance) {\n      throw new InsufficientFundsException(\"Insufficient funds in savings account\");\n    }\n    balance -= amount;\n  }\n}\n\n// Current Account class with overdraft protection and potentially different withdraw logic\nclass CurrentAccount implements Account {\n  private double balance;\n  private double overdraftLimit;\n\n  public CurrentAccount(double balance, double overdraftLimit) {\n    this.balance = balance;\n    this.overdraftLimit = overdraftLimit;\n  }\n\n  @Override\n  public void deposit(double amount) {\n    balance += amount;\n  }\n\n  @Override\n  public void withdraw(double amount) throws InsufficientFundsException {\n    if (amount > balance + overdraftLimit) {\n      throw new InsufficientFundsException(\"Insufficient funds in current account\");\n    }\n    balance -= amount;\n  }\n}\n\n// Custom exception class for insufficient funds\nclass InsufficientFundsException extends Exception {\n  public InsufficientFundsException(String message) {\n    super(message);\n  }\n}"
  },
  {
    "instruction": "Create a Java class for a School that demonstrates encapsulation by encapsulating attributes like name and location, association by associating teachers with classes, and inheritance by having subclasses like ElementarySchool and HighSchool.",
    "input":"",
    "output": "public class School {\n  private String name;\n  private String location;\n  private List<Teacher> teachers; // Association with Teacher class\n\n  public School(String name, String location) {\n    this.name = name;\n    this.location = location;\n    this.teachers = new ArrayList<>();\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getLocation() {\n    return location;\n  }\n\n  public void setLocation(String location) {\n    this.location = location;\n  }\n\n  public void addTeacher(Teacher teacher) {\n    teachers.add(teacher);\n  }\n\n  public List<Teacher> getTeachers() {\n    return Collections.unmodifiableList(teachers); // Encapsulation - return unmodifiable list\n  }\n}\n\nclass Teacher {\n  // Add attributes and methods specific to Teacher here\n}\n\nclass ElementarySchool extends School {\n\n  public ElementarySchool(String name, String location) {\n    super(name, location);\n  }\n\n  // Add methods specific to ElementarySchool here (e.g., kindergarten programs)\n}\n\nclass HighSchool extends School {\n\n  public HighSchool(String name, String location) {\n    super(name, location);\n  }\n\n  // Add methods specific to HighSchool here (e.g., advanced placement classes)\n}"
  },
  {
    "instruction": "Implement a Java class for a Movie that exhibits encapsulation by encapsulating attributes like title and genre, aggregation by aggregating actors, and polymorphism by providing methods like play() for different genres.",
    "input":"",
    "output": "class Actor {\n  private String name;\n\n  public Actor(String name) {\n    this.name = name;\n  }\n\n  public String getName() {\n    return name;\n  }\n}\n\nclass Movie {\n  private String title; // Encapsulation with private attribute\n  private String genre;\n  private List<Actor> actors; // Aggregation\n\n  public Movie(String title, String genre) {\n    this.title = title;\n    this.genre = genre;\n    this.actors = new ArrayList<>();\n  }\n\n  public void addActor(Actor actor) {\n    actors.add(actor);\n  }\n\n  public void play() {\n    System.out.println(f\"Playing {title} ({genre})\");\n    // Polymorphism: Specific play behavior for different genres can be implemented here\n    // For example:\n    if (genre.equals(\"Comedy\")) {\n      System.out.println(\"Playing funny scenes...\");\n    } else if (genre.equals(\"Drama\")) {\n      System.out.println(\"Playing emotional scenes...\");\n    } else if (genre.equals(\"Action\")) {\n      System.out.println(\"Playing intense action sequences...\");\n    } else {\n      System.out.println(\"Playing the movie...\"); // Default behavior\n    }\n  }\n}"
  }
]